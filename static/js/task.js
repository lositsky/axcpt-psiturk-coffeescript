// Generated by CoffeeScript 1.9.1
(function() {
  var DotsExperiment, DotsTrial, Experiment, ExtMath, LettersExperiment, PracticeLetterTrial, Renderer, TestLetterTrial, Trial, base, r,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  ExtMath = (function(superClass) {
    extend(ExtMath, superClass);

    function ExtMath() {
      return ExtMath.__super__.constructor.apply(this, arguments);
    }

    ExtMath.round = function(x, precision) {
      var scale;
      if (precision == null) {
        precision = 0;
      }
      scale = Math.pow(10, precision);
      return Math.round(x * scale) / scale;
    };

    return ExtMath;

  })(Math);

  if ((base = Array.prototype).shuffle == null) {
    base.shuffle = function() {
      var i, j, k, ref, ref1;
      if (this.length > 1) {
        for (i = k = ref = this.length - 1; ref <= 1 ? k <= 1 : k >= 1; i = ref <= 1 ? ++k : --k) {
          j = Math.floor(Math.random() * (i + 1));
          ref1 = [this[j], this[i]], this[i] = ref1[0], this[j] = ref1[1];
        }
      }
      return this;
    };
  }

  Renderer = (function() {
    function Renderer() {
      this.clearScreen = bind(this.clearScreen, this);
    }

    Renderer.prototype.drawingContext = null;

    Renderer.prototype.createDrawingContext = function(fontParams) {
      this.canvas = document.createElement('canvas');
      document.body.appendChild(this.canvas);
      this.canvas.style.display = "block";
      this.canvas.style.margin = "0 auto";
      this.canvas.style.padding = "0";
      this.canvas.width = 1024;
      this.canvas.height = 768;
      this.drawingContext = this.canvas.getContext('2d');
      this.drawingContext.font = fontParams;
      return this.drawingContext.textAlign = "center";
    };

    Renderer.prototype.renderText = function(text, color, shiftx, shifty) {
      if (color == null) {
        color = "black";
      }
      if (shiftx == null) {
        shiftx = 0;
      }
      if (shifty == null) {
        shifty = 0;
      }
      return this.fillTextMultiLine(this.drawingContext, text, this.canvas.width / 2 + shiftx, this.canvas.height / 2 + shifty, color);
    };

    Renderer.prototype.fillTextMultiLine = function(ctx, text, x, y, color) {
      var k, len, line, lineHeight, lines, results;
      lineHeight = ctx.measureText("M").width * 1.4;
      lines = text.split("\n");
      ctx.fillStyle = color;
      results = [];
      for (k = 0, len = lines.length; k < len; k++) {
        line = lines[k];
        ctx.fillText(line, x, y);
        results.push(y += lineHeight);
      }
      return results;
    };

    Renderer.prototype.renderCircle = function(x, y, radius, fill, color) {
      if (fill == null) {
        fill = true;
      }
      if (color == null) {
        color = "black";
      }
      this.drawingContext.strokeStyle = 'color';
      this.drawingContext.beginPath();
      this.drawingContext.arc(x, y, radius, 0, 2 * Math.PI, false);
      this.drawingContext.fillStyle = 'white';
      if (fill) {
        this.drawingContext.fillStyle = color;
        this.drawingContext.fill();
      }
      this.drawingContext.lineWidth = 1;
      return this.drawingContext.stroke();
    };

    Renderer.prototype.renderDots = function(stim, color, shiftX, shiftY, radius, sep) {
      var centerx, centery, i, k, len, offset, offsets, results;
      if (color == null) {
        color = "black";
      }
      if (shiftX == null) {
        shiftX = 0;
      }
      if (shiftY == null) {
        shiftY = 0;
      }
      if (radius == null) {
        radius = 10;
      }
      if (sep == null) {
        sep = 20;
      }
      centerx = this.canvas.width / 2;
      centery = this.canvas.height / 2;
      offsets = [[-1, -1], [1, -1], [-1, 1], [1, 1]];
      results = [];
      for (i = k = 0, len = offsets.length; k < len; i = ++k) {
        offset = offsets[i];
        results.push(this.renderCircle(centerx + offset[0] * sep + shiftX, centery + offset[1] * sep + shiftY, radius, stim[i], color));
      }
      return results;
    };

    Renderer.prototype.clearScreen = function() {
      return this.drawingContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };

    return Renderer;

  })();

  Trial = (function() {
    Trial.prototype.startTime = null;

    Trial.prototype.rt = null;

    Trial.prototype.acc = null;

    Trial.prototype.bonus = null;

    Trial.prototype.next = null;

    Trial.prototype.timeout = null;

    Trial.prototype.myState = null;

    Trial.prototype.handleSpacebar = function(event) {
      if (event.keyCode === 32) {
        removeEventListener("keydown", this.handleSpacebar);
        return e.doNext();
      }
    };

    Trial.prototype.recordTrial = function() {
      return psiTurk.recordTrialData({
        "trialId": e.state.trialIdGlobal,
        "blockID": e.state.blockId,
        "context": this.context,
        "target": this.target,
        "contextItem": this.contextItem,
        "targetItem": this.targetItem,
        "cresp": this.cresp,
        "rt": this.rt,
        "acc": this.acc,
        "bonus": this.bonus
      });
    };

    Trial.prototype.handleButtonPress = function(event) {
      var ref;
      if (ref = event.keyCode, indexOf.call(this.keys, ref) >= 0) {
        removeEventListener("keydown", this.handleButtonPress);
        this.rt = performance.now() - this.startTime;
        this.acc = event.keyCode === this.cresp ? 1 : 0;
        this.computeBonus();
        clearTimeout(this.timeout);
        this.recordTrial();
        return this.showFeedback();
      }
    };

    function Trial(context, target, contextItem, targetItem, keys, cresp, contextColor, targetColor) {
      this.context = context;
      this.target = target;
      this.contextItem = contextItem;
      this.targetItem = targetItem;
      this.keys = keys;
      this.cresp = cresp;
      this.contextColor = contextColor != null ? contextColor : "black";
      this.targetColor = targetColor != null ? targetColor : "black";
      this.enableInput = bind(this.enableInput, this);
      this.showFeedback = bind(this.showFeedback, this);
      this.timedOut = bind(this.timedOut, this);
      this.run = bind(this.run, this);
      this.computeBonus = bind(this.computeBonus, this);
      this.handleButtonPress = bind(this.handleButtonPress, this);
      this.recordTrial = bind(this.recordTrial, this);
      this.handleSpacebar = bind(this.handleSpacebar, this);
    }

    Trial.prototype.computeBonus = function() {
      if (this.acc === 1) {
        this.bonus = (e.config.deadline - (this.rt / 1000)) * e.config.correctPointsPerSec;
      } else {
        this.bonus = this.rt / 1000 * e.config.incorrectPointsPerSec;
      }
      e.state.blockBonus = e.state.blockBonus + this.bonus;
      return e.state.globalBonus = e.state.globalBonus + this.bonus;
    };

    Trial.prototype.run = function(state) {
      r.clearScreen();
      this.startTime = performance.now() + e.config.retentionInterval + e.config.contextDur;
      r.renderText(this.contextItem, this.contextColor);
      setTimeout(r.clearScreen, e.config.contextDur);
      setTimeout(((function(_this) {
        return function() {
          return r.renderText(_this.targetItem, _this.targetColor);
        };
      })(this)), e.config.retentionInterval + e.config.contextDur);
      return setTimeout(this.enableInput, e.config.retentionInterval + e.config.contextDur);
    };

    Trial.prototype.timedOut = function() {
      r.clearScreen();
      r.renderText("Timed out! Press spacebar to continue.");
      removeEventListener("keydown", this.handleButtonPress);
      this.recordTrial();
      return addEventListener("keydown", this.handleSpacebar);
    };

    Trial.prototype.showFeedback = function() {
      r.clearScreen();
      if (this.acc === 1) {
        r.renderText("Correct! \n Your RT was " + (ExtMath.round(this.rt, 2)) + "ms! \n You get " + (ExtMath.round(this.bonus, 2)) + " points! \n\n Press the spacebar to continue.");
      } else {
        r.renderText("Incorrect! \n Your RT was " + (ExtMath.round(this.rt, 2)) + "ms! \n You get " + (ExtMath.round(this.bonus, 2)) + " points! \n\n Press the spacebar to continue.");
      }
      return addEventListener("keydown", this.handleSpacebar);
    };

    Trial.prototype.enableInput = function() {
      addEventListener("keydown", this.handleButtonPress);
      return this.timeout = setTimeout(this.timedOut, e.config.deadline * 1000);
    };

    return Trial;

  })();

  PracticeLetterTrial = (function(superClass) {
    extend(PracticeLetterTrial, superClass);

    function PracticeLetterTrial() {
      this.showFeedback = bind(this.showFeedback, this);
      this.recordTrial = bind(this.recordTrial, this);
      this.enableInput = bind(this.enableInput, this);
      return PracticeLetterTrial.__super__.constructor.apply(this, arguments);
    }

    PracticeLetterTrial.prototype.enableInput = function() {
      return addEventListener("keydown", this.handleButtonPress);
    };

    PracticeLetterTrial.prototype.recordTrial = function() {
      return psiTurk.recordTrialData({
        "trialId": e.state.trialIdGlobal,
        "blockID": "Practice",
        "context": this.context,
        "target": this.target,
        "contextItem": this.contextItem,
        "targetItem": this.targetItem,
        "cresp": this.cresp,
        "rt": this.rt,
        "acc": this.acc,
        "bonus": this.bonus
      });
    };

    PracticeLetterTrial.prototype.showFeedback = function() {
      r.clearScreen();
      if (this.acc === 1) {
        r.renderText("Correct!\n\n Press the spacebar to continue.", "green");
      } else {
        r.renderText("Incorrect! \n\n Press the spacebar to continue.", "red");
      }
      return addEventListener("keydown", this.handleSpacebar);
    };

    return PracticeLetterTrial;

  })(Trial);

  TestLetterTrial = (function(superClass) {
    extend(TestLetterTrial, superClass);

    function TestLetterTrial() {
      this.showFeedback = bind(this.showFeedback, this);
      this.recordTrial = bind(this.recordTrial, this);
      return TestLetterTrial.__super__.constructor.apply(this, arguments);
    }

    TestLetterTrial.prototype.recordTrial = function() {
      return psiTurk.recordTrialData({
        "trialId": e.state.testId,
        "blockID": "Test",
        "context": this.context,
        "target": this.target,
        "contextItem": this.contextItem,
        "targetItem": this.targetItem,
        "cresp": this.cresp,
        "rt": this.rt,
        "acc": this.acc,
        "bonus": this.bonus
      });
    };

    TestLetterTrial.prototype.showFeedback = function() {
      r.clearScreen();
      if (this.acc === 1) {
        e.state.currentStreak = e.state.currentStreak + 1;
        r.renderText("Correct (Streak: " + e.state.currentStreak + ")! (" + (e.config.nTestAttempts - e.state.testId - 1) + " attempts left)\n\n Press the spacebar to continue.");
      } else {
        e.state.currentStreak = 0;
        r.renderText("Incorrect! (" + (e.config.nTestAttempts - e.state.testId - 1) + " attempts left).");
        r.renderText("As a reminder, here are the rules: \n\n followed by      -->  hit the \"F\" key\n followed by      -->  hit the \"F\" key\n followed by      -->  hit the \"J\" key\n followed by      -->  hit the \"J\" key.\n\n Press the spacebar to continue.");
        r.renderText(e.stimuli[0], "blue", -240, 210);
        r.renderText(e.stimuli[2], "green", -40, 210);
        r.renderText(e.stimuli[0], "blue", -240, 140);
        r.renderText(e.stimuli[1], "green", -40, 140);
        r.renderText(e.stimuli[3], "blue", -240, 175);
        r.renderText(e.stimuli[1], "green", -40, 175);
        r.renderText(e.stimuli[3], "blue", -240, 105);
        r.renderText(e.stimuli[2], "green", -40, 105);
      }
      return addEventListener("keydown", this.handleSpacebar);
    };

    return TestLetterTrial;

  })(PracticeLetterTrial);

  DotsTrial = (function(superClass) {
    extend(DotsTrial, superClass);

    function DotsTrial(context, target, keys, cresp, contextColor, targetColor) {
      this.context = context;
      this.target = target;
      this.keys = keys;
      this.cresp = cresp;
      this.contextColor = contextColor != null ? contextColor : "black";
      this.targetColor = targetColor != null ? targetColor : "black";
      this.run = bind(this.run, this);
      DotsTrial.__super__.constructor.call(this, this.context, this.target, this.keys, this.cresp, this.contextColor, this.targetColor);
    }

    DotsTrial.prototype.run = function(state) {
      this.myState = state;
      r.clearScreen();
      this.startTime = performance.now() + this.myState.config.retentionInterval + this.myState.config.contextDur;
      r.renderDots(this.context, this.contextColor);
      setTimeout(r.clearScreen, this.myState.config.contextDur);
      setTimeout(((function(_this) {
        return function() {
          return r.renderDots(_this.target, _this.targetColor);
        };
      })(this)), this.myState.config.retentionInterval + this.myState.config.contextDur);
      return setTimeout(this.enableInput, this.myState.config.retentionInterval + this.myState.config.contextDur);
    };

    return DotsTrial;

  })(Trial);

  Experiment = (function() {
    Experiment.prototype.state = null;

    Experiment.prototype.config = null;

    function Experiment(config, trialDist, fontParams1) {
      this.config = config;
      this.trialDist = trialDist != null ? trialDist : [0.5, 0.2, 0.2, 0.1];
      this.fontParams = fontParams1 != null ? fontParams1 : "30px sans-serif";
      this.handleSpacebar = bind(this.handleSpacebar, this);
      this.state = {
        blockId: 0,
        trialIdGlobal: 0,
        aPraxId: 0,
        bPraxId: 0,
        testId: 0,
        blockBonus: 0,
        globalBonus: 0,
        currentStreak: 0,
        phase: "initialInstructions"
      };
      this.config.nTrials = this.config.blockSize * this.config.nBlocks;
      this.config.payoffId = this.createInitialState;
      r.createDrawingContext(this.fontParams);
      this.createTrialTypes();
      this.shuffleTrials();
    }

    Experiment.prototype.shuffleTrials = function() {
      var i, tc, td, trialCounts;
      trialCounts = (function() {
        var k, len, ref, results;
        ref = this.trialDist;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          td = ref[k];
          results.push(td * this.config.nTrials);
        }
        return results;
      }).call(this);
      this.trialOrder = [];
      this.trialOrder = (function() {
        var k, len, results;
        results = [];
        for (i = k = 0, len = trialCounts.length; k < len; i = ++k) {
          tc = trialCounts[i];
          results.push((function() {
            var l, ref, results1;
            results1 = [];
            for (l = 1, ref = tc; 1 <= ref ? l <= ref : l >= ref; 1 <= ref ? l++ : l--) {
              results1.push(this.trialOrder.concat(i));
            }
            return results1;
          }).call(this));
        }
        return results;
      }).call(this);
      return this.trialOrder.shuffle();
    };

    Experiment.prototype.handleSpacebar = function(event) {
      if (event.keyCode === 32) {
        removeEventListener("keydown", this.handleSpacebar);
        this.state.instructionSlide = this.state.instructionSlide + 1;
        return this.showInstructions();
      }
    };

    Experiment.prototype.setState = function(state) {
      return this.state = state;
    };

    Experiment.prototype.run = function() {
      return this.doNext();
    };

    Experiment.prototype.doNext = function() {
      r.clearScreen();
      switch (this.state.phase) {
        case "initialInstructions":
          this.state.instructionSlide = 0;
          return this.showInstructions();
        case "APractice":
          this.state.aPraxId = this.state.aPraxId + 1;
          this.state.trialIdGlobal = this.state.trialIdGlobal + 1;
          if (this.state.aPraxId < this.config.nPraxTrials) {
            return setTimeout(((function(_this) {
              return function() {
                return _this.praxTrialTypes[_this.aPrax[_this.state.aPraxId]].run();
              };
            })(this)), this.config.iti);
          } else {
            this.state.instructionSlide = 4;
            return this.showInstructions();
          }
          break;
        case "BPractice":
          this.state.bPraxId = this.state.bPraxId + 1;
          this.state.trialIdGlobal = this.state.trialIdGlobal + 1;
          if (this.state.bPraxId < this.config.nPraxTrials) {
            return setTimeout(((function(_this) {
              return function() {
                return _this.praxTrialTypes[_this.bPrax[_this.state.bPraxId]].run();
              };
            })(this)), this.config.iti);
          } else {
            this.state.instructionSlide = 6;
            return this.showInstructions();
          }
          break;
        case "test":
          this.state.testId = this.state.testId + 1;
          this.state.trialIdGlobal = this.state.trialIdGlobal + 1;
          if (this.state.currentStreak === this.config.testStreakToPass) {
            psiTurk.recordUnstructuredData("trialsToLearn", this.state.testId);
            this.state.instructionSlide = 8;
            return this.showInstructions();
          } else if (this.state.testId < this.config.nTestAttempts) {
            return setTimeout(((function(_this) {
              return function() {
                return _this.testTrialTypes[_this.testTrialOrder[_this.state.testId]].run();
              };
            })(this)), this.config.iti);
          } else {
            return this.endExperimentFail();
          }
          break;
        case "experiment":
          this.state.trialIdGlobal = this.state.trialIdGlobal + 1;
          if (this.state.trialIdGlobal === this.config.nTrials) {
            return this.endExperimentTrials();
          } else if ((this.state.globalBonus / this.config.pointsPerDollar) >= this.config.maxBonus) {
            return this.endExperimentMoney();
          } else if ((modulo(this.state.trialIdGlobal, this.config.blockSize)) === 0) {
            this.state.blockId = this.state.blockId + 1;
            return this.blockFeedback();
          } else {
            return setTimeout(((function(_this) {
              return function() {
                return _this.trialTypes[_this.trialOrder[_this.state.trialIdGlobal]].run();
              };
            })(this)), this.config.iti);
          }
      }
    };

    Experiment.prototype.endExperiment = function() {
      psiTurk.saveData();
      return psiTurk.completeHIT();
    };

    Experiment.prototype.endExperimentMoney = function() {
      r.clearScreen();
      r.renderText("Congratulations! You have achieved the maximum possible bonus.\n You will be paid $" + (this.config.minPayment + this.config.maxBonus) + " for your time.\n If you have any questions, email " + this.config.experimenterEmail + "\n You may close this window now.");
      return this.endExperiment();
    };

    Experiment.prototype.endExperimentTrials = function() {
      var cashBonus;
      r.clearScreen();
      cashBonus = this.state.globalBonus < 0 ? 0 : ExtMath.round(this.state.globalBonus / this.config.pointsPerDollar, 2);
      r.renderText("Thank you! This concludes the experiment.\n Based on achieving " + (ExtMath.round(this.state.globalBonus, 2)) + " points,\n you will be paid $" + cashBonus + " for your time.\n If you have any questions, email " + this.config.experimenterEmail + "\n You may close this window now.");
      return this.endExperiment();
    };

    Experiment.prototype.endExperimentFail = function() {
      r.clearScreen();
      r.renderText("Unfortunately, you were unable to get " + this.config.testStreakToPass + " correct in a row.\n This means that you cannot continue with the experiment.\n You will receive $" + this.config.minPayment + " for your time.\n If you have any questions, email " + this.config.experimenterEmail + "\n You may close this window now.");
      psiTurk.saveData();
      return this.endExperiment();
    };

    Experiment.prototype.startExperiment = function() {
      this.state.phase = "experiment";
      psiTurk.finishInstructions();
      this.state.trialIdGlobal = 0;
      return this.trialTypes[this.trialOrder[0]].run();
    };

    Experiment.prototype.blockFeedback = function() {
      var feedbackText;
      r.clearScreen();
      feedbackText = "Done with this block! ! \n Your bonus for this block was " + (ExtMath.round(this.state.blockBonus, 2)) + "!\n Your bonus for the experiment so far is " + (ExtMath.round(this.state.globalBonus, 2)) + "!\n Please take a short break.\n The experiment will continue in " + this.config.blockRestDur + " seconds.";
      r.renderText(feedbackText);
      this.state.blockBonus = 0;
      setTimeout(((function(_this) {
        return function() {
          return _this.trialTypes[_this.trialOrder[_this.state.trialIdGlobal]].run(_this);
        };
      })(this)), this.config.blockRestDur * 1000);
      return psiTurk.saveData();
    };

    return Experiment;

  })();

  DotsExperiment = (function(superClass) {
    extend(DotsExperiment, superClass);

    function DotsExperiment() {
      return DotsExperiment.__super__.constructor.apply(this, arguments);
    }

    DotsExperiment.prototype.stimuli = [[0, 0, 0, 1], [0, 0, 1, 0], [0, 0, 1, 1], [0, 1, 0, 0], [0, 1, 0, 1], [0, 1, 1, 0], [0, 1, 1, 1], [1, 0, 0, 0], [1, 0, 0, 1], [1, 0, 1, 0], [1, 0, 1, 1], [1, 1, 0, 0], [1, 1, 0, 1], [1, 1, 1, 0], [1, 1, 1, 1]];

    DotsExperiment.prototype.createTrialTypes = function() {
      this.stimuli.shuffle();
      return this.trialTypes = [new DotsTrial(this.stimuli[0], this.stimuli[1], [70, 74], 70, "blue", "green"), new DotsTrial(this.stimuli[0], this.stimuli[2], [70, 74], 74, "blue", "green"), new DotsTrial(this.stimuli[3], this.stimuli[1], [70, 74], 74, "blue", "green"), new DotsTrial(this.stimuli[3], this.stimuli[2], [70, 74], 70, "blue", "green")];
    };

    DotsExperiment.prototype.showInstructions = function() {
      switch (this.instructionSlide) {
        case 0:
          r.renderText("Welcome to the experiment!\n In this experiment, you will make responses to pairs of stimuli.\n The two stimuli in each pair will be separated by a blank screen.\n\n Press the spacebar to continue.");
          return addEventListener("keydown", this.handleSpacebar);
        case 1:
          r.clearScreen();
          r.renderText("If you see the symbol    followed by the symbol    , hit the \"F\" Key.\n Do the same if you see the symbol    followed by the symbol    \n\n But if you see the symbol    followed by the symbol    \n or the symbol    followed by the symbol    , hit the \"J\" Key.\n\n Press the spacebar to continue.");
          r.renderDots(this.stimuli[0], "blue", -132.5, -7.5, 4, 5);
          r.renderDots(this.stimuli[3], "blue", 67, 28, 4, 5);
          r.renderDots(this.stimuli[0], "blue", 3, 98, 4, 5);
          r.renderDots(this.stimuli[3], "blue", -178, 133, 4, 5);
          r.renderDots(this.stimuli[1], "green", 210, -7.5, 4, 5);
          r.renderDots(this.stimuli[2], "green", 400, 28, 4, 5);
          r.renderDots(this.stimuli[2], "green", 340, 98, 4, 5);
          r.renderDots(this.stimuli[1], "green", 165, 133, 4, 5);
          return addEventListener("keydown", this.handleSpacebar);
        case 2:
          r.clearScreen();
          return this.state.startExperiment();
      }
    };

    return DotsExperiment;

  })(Experiment);

  LettersExperiment = (function(superClass) {
    extend(LettersExperiment, superClass);

    function LettersExperiment() {
      return LettersExperiment.__super__.constructor.apply(this, arguments);
    }

    LettersExperiment.prototype.createTrialTypes = function() {
      var i, k, l, len, len1, len2, m, n, o, p, pc, praxCounts, ref, ref1, ref2, tc, testCounts;
      this.stimuli = ["A", "B", "C", "D", "E", "F", "G"];
      this.stimuli.shuffle();
      this.trialTypes = [new Trial("A", "X", this.stimuli[0], this.stimuli[1], [70, 74], 70, "blue", "green"), new Trial("A", "Y", this.stimuli[0], this.stimuli[2], [70, 74], 74, "blue", "green"), new Trial("B", "X", this.stimuli[3], this.stimuli[1], [70, 74], 74, "blue", "green"), new Trial("B", "Y", this.stimuli[3], this.stimuli[2], [70, 74], 70, "blue", "green")];
      this.praxTrialTypes = [new PracticeLetterTrial("A", "X", this.stimuli[0], this.stimuli[1], [70, 74], 70, "blue", "green"), new PracticeLetterTrial("A", "Y", this.stimuli[0], this.stimuli[2], [70, 74], 74, "blue", "green"), new PracticeLetterTrial("B", "X", this.stimuli[3], this.stimuli[1], [70, 74], 74, "blue", "green"), new PracticeLetterTrial("B", "Y", this.stimuli[3], this.stimuli[2], [70, 74], 70, "blue", "green")];
      this.testTrialTypes = [new TestLetterTrial("A", "X", this.stimuli[0], this.stimuli[1], [70, 74], 70, "blue", "green"), new TestLetterTrial("A", "Y", this.stimuli[0], this.stimuli[2], [70, 74], 74, "blue", "green"), new TestLetterTrial("B", "X", this.stimuli[3], this.stimuli[1], [70, 74], 74, "blue", "green"), new TestLetterTrial("B", "Y", this.stimuli[3], this.stimuli[2], [70, 74], 70, "blue", "green")];
      praxCounts = (function() {
        var k, results;
        results = [];
        for (i = k = 1; k <= 2; i = ++k) {
          results.push(this.config.nPraxTrials / 2);
        }
        return results;
      }).call(this);
      this.aPrax = [];
      this.bPrax = [];
      for (i = k = 0, len = praxCounts.length; k < len; i = ++k) {
        pc = praxCounts[i];
        for (l = 1, ref = pc; 1 <= ref ? l <= ref : l >= ref; 1 <= ref ? l++ : l--) {
          this.aPrax = this.aPrax.concat(i);
        }
      }
      for (i = m = 0, len1 = praxCounts.length; m < len1; i = ++m) {
        pc = praxCounts[i];
        for (n = 1, ref1 = pc; 1 <= ref1 ? n <= ref1 : n >= ref1; 1 <= ref1 ? n++ : n--) {
          this.bPrax = this.bPrax.concat(i + 2);
        }
      }
      this.aPrax.shuffle();
      this.bPrax.shuffle();
      testCounts = (function() {
        var o, results;
        results = [];
        for (i = o = 1; o <= 4; i = ++o) {
          results.push(this.config.nTestAttempts / 4);
        }
        return results;
      }).call(this);
      this.testTrialOrder = [];
      for (i = o = 0, len2 = testCounts.length; o < len2; i = ++o) {
        tc = testCounts[i];
        for (p = 1, ref2 = tc; 1 <= ref2 ? p <= ref2 : p >= ref2; 1 <= ref2 ? p++ : p--) {
          this.testTrialOrder = this.testTrialOrder.concat(i);
        }
      }
      return this.testTrialOrder.shuffle();
    };

    LettersExperiment.prototype.showInstructions = function() {
      switch (this.state.instructionSlide) {
        case 0:
          r.renderText("Welcome to the experiment!\n In this experiment, you will make responses to pairs of stimuli.\n The two stimuli in each pair will be separated by a blank screen.\n There will be one correct response for each pair of stimuli.\n\n");
          setTimeout((function() {
            return r.renderText("Press the spacebar to continue.", "black", 0, 200);
          }), this.config.spacebarTimeout);
          return setTimeout(((function(_this) {
            return function() {
              return addEventListener("keydown", _this.handleSpacebar);
            };
          })(this)), this.config.spacebarTimeout);
        case 1:
          r.clearScreen();
          r.renderText("First, you will learn the rules mapping stimuli to responses.\n Then, we will test that you learned the mappings.\n If you fail, the HIT will end and you will earn the minimum payment ($" + this.config.minPayment + ").\n If you succeed, you will compete for an additional bonus of up to $" + this.config.maxBonus + ".");
          setTimeout((function() {
            return r.renderText("Press the spacebar to continue.", "black", 0, 200);
          }), this.config.spacebarTimeout);
          return setTimeout(((function(_this) {
            return function() {
              return addEventListener("keydown", _this.handleSpacebar);
            };
          })(this)), this.config.spacebarTimeout);
        case 2:
          r.clearScreen();
          r.renderText("Here is the first rule:\n followed by      -->  hit the \"F\" key\n followed by      -->  hit the \"J\" key\n\n Now you will get a chance to practice.");
          r.renderText(this.stimuli[0], "blue", -240, 35);
          r.renderText(this.stimuli[1], "green", -40, 35);
          r.renderText(this.stimuli[0], "blue", -240, 75);
          r.renderText(this.stimuli[2], "green", -40, 75);
          setTimeout((function() {
            return r.renderText("Press the spacebar to continue.", "black", 0, 200);
          }), this.config.spacebarTimeout);
          return setTimeout(((function(_this) {
            return function() {
              return addEventListener("keydown", _this.handleSpacebar);
            };
          })(this)), this.config.spacebarTimeout);
        case 3:
          this.state.phase = "APractice";
          return this.praxTrialTypes[this.aPrax[0]].run();
        case 4:
          r.clearScreen();
          r.renderText("Here is the second rule:\n followed by      -->  hit the \"F\" key\n followed by      -->  hit the \"J\" key\n\n Now you will get a chance to practice.");
          r.renderText(this.stimuli[3], "blue", -240, 35);
          r.renderText(this.stimuli[2], "green", -40, 35);
          r.renderText(this.stimuli[3], "blue", -240, 75);
          r.renderText(this.stimuli[1], "green", -40, 75);
          setTimeout((function() {
            return r.renderText("Press the spacebar to continue.", "black", 0, 200);
          }), this.config.spacebarTimeout);
          return setTimeout(((function(_this) {
            return function() {
              return addEventListener("keydown", _this.handleSpacebar);
            };
          })(this)), this.config.spacebarTimeout);
        case 5:
          this.state.phase = "BPractice";
          return this.praxTrialTypes[this.bPrax[0]].run();
        case 6:
          r.clearScreen();
          r.renderText("Now, we will test that you have learned the rules.\n You will see a sequence of trials. Your goal is to get " + this.config.testStreakToPass + " correct in a row.\n You will have " + this.config.nTestAttempts + " trials total. If you get " + this.config.testStreakToPass + " correct in a row, you can compete\n for a bonus of up to $" + this.config.maxBonus + ". If you get to " + this.config.nTestAttempts + " without getting " + this.config.testStreakToPass + " in a row, \n the HIT will end and you will get the minimum payment ($" + this.config.minPayment + ").\n\n As a reminder, here are the rules: \n followed by      -->  hit the \"F\" key\n followed by      -->  hit the \"F\" key\n followed by      -->  hit the \"J\" key\n followed by      -->  hit the \"J\" key", "black", 0, -200);
          r.renderText(this.stimuli[0], "blue", -240, 155);
          r.renderText(this.stimuli[2], "green", -40, 155);
          r.renderText(this.stimuli[0], "blue", -240, 80);
          r.renderText(this.stimuli[1], "green", -40, 80);
          r.renderText(this.stimuli[3], "blue", -240, 120);
          r.renderText(this.stimuli[1], "green", -40, 120);
          r.renderText(this.stimuli[3], "blue", -240, 45);
          r.renderText(this.stimuli[2], "green", -40, 45);
          setTimeout((function() {
            return r.renderText("Press the spacebar to continue.", "black", 0, 200);
          }), this.config.spacebarTimeout);
          return setTimeout(((function(_this) {
            return function() {
              return addEventListener("keydown", _this.handleSpacebar);
            };
          })(this)), this.config.spacebarTimeout);
        case 7:
          r.clearScreen();
          this.state.phase = "test";
          return this.testTrialTypes[this.testTrialOrder[0]].run();
        case 8:
          r.clearScreen();
          r.renderText("Congratulations! You have learned the rules.\n You will now see up to " + this.config.nTrials + " more trials in blocks of " + this.config.blockSize + ". \n You will receive " + this.config.correctPointsPerSec + " points per second under " + this.config.deadline + "s on a correct response.\n You will receive " + this.config.incorrectPointsPerSec + " points per second on an incorrect response.\n You will receive $1 for each " + this.config.pointsPerDollar + " points.\n Even if your point total is negative, you cannot earn less than the $" + this.config.minPayment + " minimum payment\n The HIT will end when you have done " + this.config.nTrials + " trials total or earned " + (this.config.maxBonus * this.config.pointsPerDollar) + " points.\n\n As a reminder, here are the rules: \n followed by      -->  hit the \"F\" key\n followed by      -->  hit the \"F\" key\n followed by      -->  hit the \"J\" key\n followed by      -->  hit the \"J\" key", "black", 0, -200);
          r.renderText(this.stimuli[0], "blue", -240, 220);
          r.renderText(this.stimuli[2], "green", -40, 220);
          r.renderText(this.stimuli[0], "blue", -240, 150);
          r.renderText(this.stimuli[1], "green", -40, 150);
          r.renderText(this.stimuli[3], "blue", -240, 185);
          r.renderText(this.stimuli[1], "green", -40, 185);
          r.renderText(this.stimuli[3], "blue", -240, 115);
          r.renderText(this.stimuli[2], "green", -40, 115);
          setTimeout((function() {
            return r.renderText("Press the spacebar to continue.", "black", 0, 260);
          }), this.config.spacebarTimeout);
          return setTimeout(((function(_this) {
            return function() {
              return addEventListener("keydown", _this.handleSpacebar);
            };
          })(this)), this.config.spacebarTimeout);
        case 9:
          r.clearScreen();
          return this.startExperiment();
      }
    };

    return LettersExperiment;

  })(Experiment);

  window.Experiment = LettersExperiment;

  window.Renderer = Renderer;

  r = new Renderer();

}).call(this);
