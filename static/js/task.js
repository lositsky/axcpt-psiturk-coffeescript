// Generated by CoffeeScript 1.9.1
(function() {
  var Experiment, ExtMath, Renderer, State, Trial, base, r,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ExtMath = (function(superClass) {
    extend(ExtMath, superClass);

    function ExtMath() {
      return ExtMath.__super__.constructor.apply(this, arguments);
    }

    ExtMath.round = function(x, precision) {
      var scale;
      if (precision == null) {
        precision = 0;
      }
      scale = Math.pow(10, precision);
      return Math.round(x * scale) / scale;
    };

    return ExtMath;

  })(Math);

  if ((base = Array.prototype).shuffle == null) {
    base.shuffle = function() {
      var i, j, k, ref, ref1;
      if (this.length > 1) {
        for (i = k = ref = this.length - 1; ref <= 1 ? k <= 1 : k >= 1; i = ref <= 1 ? ++k : --k) {
          j = Math.floor(Math.random() * (i + 1));
          ref1 = [this[j], this[i]], this[i] = ref1[0], this[j] = ref1[1];
        }
      }
      return this;
    };
  }

  State = (function() {
    State.prototype.blockId = 0;

    State.prototype.trialIdBlock = 0;

    State.prototype.trialIdGlobal = 0;

    State.prototype.blockBonus = 0;

    State.prototype.globalBonus = 0;

    function State(config1) {
      this.config = config1;
    }

    State.prototype.startExperiment = function() {
      return this.config.trialTypes[this.config.trialOrder[this.trialIdGlobal]].run(this);
    };

    State.prototype.endExperiment = function() {
      return psiTurk.saveData();
    };

    State.prototype.blockFeedback = function() {
      var feedbackText;
      if (this.blockId > (this.config.nBlocks - 1)) {
        this.endExperiment();
        r.clearScreen();
        return r.renderText("DONE!");
      } else {
        r.clearScreen();
        feedbackText = "Done with this block! ! \n Your bonus for this block was " + (ExtMath.round(this.blockBonus, 2)) + "!\n Your bonus for the experiment so far is " + (ExtMath.round(this.globalBonus)) + "!\n Please take a short break. The experiment will continue in 10 seconds.";
        r.renderText(feedbackText);
        return setTimeout(((function(_this) {
          return function() {
            return _this.config.trialTypes[_this.config.trialOrder[_this.trialIdGlobal]].run(_this);
          };
        })(this)), 2000);
      }
    };

    State.prototype.runNextTrial = function() {
      this.trialIdGlobal = this.trialIdGlobal + 1;
      this.trialIdBlock = this.trialIdBlock + 1;
      console.log("new trial");
      console.log(this.trialIdBlock);
      console.log(this.config.blockSize);
      if (this.trialIdBlock >= this.config.blockSize) {
        this.trialIdBlock = 0;
        this.blockBonus = 0;
        this.blockId = this.blockId + 1;
        return this.blockFeedback();
      } else {
        return this.config.trialTypes[this.config.trialOrder[this.trialIdGlobal]].run(this);
      }
    };

    return State;

  })();

  Trial = (function() {
    Trial.prototype.startTime = null;

    Trial.prototype.rt = null;

    Trial.prototype.acc = null;

    Trial.prototype.bonus = null;

    Trial.prototype.next = null;

    Trial.prototype.timeout = null;

    Trial.prototype.myState = null;

    Trial.prototype.handleSpacebar = function(event) {
      if (event.keyCode === 32) {
        removeEventListener("keydown", this.handleSpacebar);
        return this.myState.runNextTrial();
      }
    };

    Trial.prototype.handleButtonPress = function(event) {
      var ref;
      if (ref = event.keyCode, indexOf.call(this.keys, ref) >= 0) {
        removeEventListener("keydown", this.handleButtonPress);
        this.rt = performance.now() - this.startTime;
        this.acc = event.keyCode === this.cresp ? 1 : 0;
        this.computeBonus();
        clearTimeout(this.timeout);
        psiTurk.recordTrialData([this.trialIdGlobal, this.trialIdBlock, this.blockID, this.context, this.target, this.cresp, this.rt, this.acc, this.bonus]);
        return this.showFeedback();
      }
    };

    function Trial(context, target, keys, cresp, timeoutDur) {
      this.context = context;
      this.target = target;
      this.keys = keys;
      this.cresp = cresp;
      this.timeoutDur = timeoutDur != null ? timeoutDur : 10000;
      this.enableInput = bind(this.enableInput, this);
      this.showFeedback = bind(this.showFeedback, this);
      this.timedOut = bind(this.timedOut, this);
      this.run = bind(this.run, this);
      this.computeBonus = bind(this.computeBonus, this);
      this.handleButtonPress = bind(this.handleButtonPress, this);
      this.handleSpacebar = bind(this.handleSpacebar, this);
    }

    Trial.prototype.computeBonus = function() {
      this.bonus = this.acc === 1 ? 100 : -50;
      this.bonus = this.bonus - this.rt * 0.1;
      this.myState.blockBonus = this.myState.blockBonus + this.bonus;
      return this.myState.globalBonus = this.myState.globalBonus + this.bonus;
    };

    Trial.prototype.run = function(state) {
      this.myState = state;
      r.clearScreen();
      this.startTime = performance.now() + 1000;
      r.renderText(this.context);
      setTimeout(r.clearScreen, 500);
      setTimeout(((function(_this) {
        return function() {
          return r.renderText(_this.target);
        };
      })(this)), 2500);
      return setTimeout(this.enableInput, 2500);
    };

    Trial.prototype.timedOut = function() {
      r.clearScreen();
      r.renderText("Timed out! -300 points! Press spacebar to continue.");
      psiTurk.recordTrialData({
        'myID': this.myID,
        'context': this.context,
        'target': this.target,
        'cresp': this.cresp,
        'rt': this.rt,
        'acc': this.acc,
        'bonus': this.bonus
      });
      return addEventListener("keydown", this.handleSpacebar);
    };

    Trial.prototype.showFeedback = function() {
      var feedbackText;
      r.clearScreen();
      if (this.acc === 1) {
        feedbackText = "Correct! \n Your RT was " + (ExtMath.round(this.rt, 2)) + "ms! \n You get " + (ExtMath.round(this.bonus, 2)) + " points! \n\n Press the spacebar to continue.";
      } else {
        feedbackText = "Wrong! \n Your RT was " + (ExtMath.round(this.rt, 2)) + "ms! \n You get " + (ExtMath.round(this.bonus, 2)) + " points! \n\n Press the spacebar to continue.";
      }
      r.renderText(feedbackText);
      return addEventListener("keydown", this.handleSpacebar);
    };

    Trial.prototype.enableInput = function() {
      addEventListener("keydown", this.handleButtonPress);
      return this.timeout = setTimeout(this.timedOut, this.timeoutDur);
    };

    return Trial;

  })();

  Renderer = (function() {
    function Renderer() {
      this.clearScreen = bind(this.clearScreen, this);
    }

    Renderer.prototype.drawingContext = null;

    Renderer.prototype.createDrawingContext = function(fontParams) {
      this.canvas = document.createElement('canvas');
      document.body.appendChild(this.canvas);
      this.canvas.style.display = "block";
      this.canvas.style.margin = "0 auto";
      this.canvas.style.padding = "0";
      this.canvas.width = 800;
      this.canvas.height = 600;
      this.drawingContext = this.canvas.getContext('2d');
      this.drawingContext.font = fontParams;
      return this.drawingContext.textAlign = "center";
    };

    Renderer.prototype.renderText = function(text) {
      return this.fillTextMultiLine(this.drawingContext, text, 400, 300);
    };

    Renderer.prototype.fillTextMultiLine = function(ctx, text, x, y) {
      var k, len, line, lineHeight, lines, results;
      lineHeight = ctx.measureText("M").width * 1.4;
      lines = text.split("\n");
      results = [];
      for (k = 0, len = lines.length; k < len; k++) {
        line = lines[k];
        ctx.fillText(line, x, y);
        results.push(y += lineHeight);
      }
      return results;
    };

    Renderer.prototype.clearScreen = function() {
      return this.drawingContext.clearRect(0, 0, 800, 600);
    };

    return Renderer;

  })();

  Experiment = (function() {
    function Experiment(trialDist, nTrials, fontParams1) {
      this.trialDist = trialDist != null ? trialDist : [0.5, 0.2, 0.2, 0.1];
      this.nTrials = nTrials != null ? nTrials : 10;
      this.fontParams = fontParams1 != null ? fontParams1 : "30px sans-serif";
      this.createInitialState;
      r.createDrawingContext(this.fontParams);
      this.createTrialTypes();
      this.shuffleTrials();
    }

    Experiment.prototype.shuffleTrials = function() {
      var i, k, l, len, ref, tc, td, trialCounts;
      trialCounts = (function() {
        var k, len, ref, results;
        ref = this.trialDist;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          td = ref[k];
          results.push(td * this.nTrials);
        }
        return results;
      }).call(this);
      this.trialOrder = [];
      for (i = k = 0, len = trialCounts.length; k < len; i = ++k) {
        tc = trialCounts[i];
        for (l = 1, ref = tc; 1 <= ref ? l <= ref : l >= ref; 1 <= ref ? l++ : l--) {
          this.trialOrder = this.trialOrder.concat(i);
        }
      }
      return this.trialOrder.shuffle();
    };

    Experiment.prototype.createTrialTypes = function() {
      return this.trialTypes = [new Trial("A", "X", [70, 74], 70), new Trial("A", "Y", [70, 74], 70), new Trial("B", "X", [70, 74], 70), new Trial("B", "Y", [70, 74], 70)];
    };

    Experiment.prototype.run = function() {
      var config, expState;
      config = {
        blockSize: 5,
        nBlocks: 2,
        trialTypes: this.trialTypes,
        trialOrder: this.trialOrder
      };
      expState = new State(config);
      return expState.startExperiment();
    };

    return Experiment;

  })();

  window.Experiment = Experiment;

  window.Renderer = Renderer;

  r = new Renderer();

}).call(this);
